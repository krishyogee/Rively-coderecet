package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"flint/graph/model"
	"flint/internal/service"
	"flint/pkg/logger/audit"
	custom_err "flint/pkg/logger/errors"
	"fmt"

	"go.uber.org/zap"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.SignupResponse, error) {
	// panic(fmt.Errorf("not implemented: Signup - signup"))
	// Call the clerk service to create a new user with the input details.
	user, err := r.clerkService.CreateUser(ctx, input.Email, input.Password)
	if err != nil {
		audit.GetConsoleLogger().Error("Error while adding user in clerk", zap.String("error_code", "500"), zap.String("err", err.Error()))
		customErr := custom_err.NewGlobalError("email already registered",
			"Email domain already exists. Please contact admin or reach out to support (support@rively.com).")
		fmt.Printf("Resolver returning error of type: %T\n", customErr)

		fmt.Printf("Created custom error: %T: %+v\n", customErr, customErr)
		return nil, &custom_err.GraphQLError{
			Message:                "email already registered",
			Code:                   "EMAIL_REGISTERED",
			Type:                   "VALIDATION",
			UserError:              true,
			UserPresentableMessage: "Email already registered. Please use a different email.",
		}

	}

	// Create a SignupCreateUser struct to pass to the AuthService.
	signupInput := service.SignupCreateUser{
		Email:    input.Email,
		Customer: "", // Similarly, update if the company name or customer info is needed.
		Password: input.Password,
		ClerkId:  user.ID,
	}

	// Create the user in the database using the AuthService.
	usr, err := r.authService.SignupCreateUser(ctx, signupInput)
	if err != nil {
		audit.GetConsoleLogger().Error("Error while adding user in database", zap.String("error_code", "500"), zap.String("err", err.Error()))
		return nil, errors.New("something went wrong on our side, please try again later")
	}

	// Prepare the response based on the created user details.
	customerUIDStr := usr.CustomerUID // Create a variable to hold the string value

	response := &model.SignupResponse{
		// User:       &model.User{ID: usr.ID, Name: usr.UserName},
		UserID:      usr.UserUID,
		ClerkID:     usr.ClerkID,
		CustomerUID: customerUIDStr,
	}

	return response, nil
}

// VerifyCustomer is the resolver for the verifyCustomer field.
func (r *mutationResolver) VerifyCustomer(ctx context.Context, input model.VerifyCustomerInput) (*model.VerifyCustomerResponse, error) {
	// panic(fmt.Errorf("not implemented: VerifyCustomer - verifyCustomer"))
	fmt.Println("Verifyy customer")
	customer, err := r.authService.VerifyCustomer(ctx, input.Token)
	if err != nil {
		fmt.Println("Error", err)
	}
	// get user by ig
	fmt.Println("customer", customer)
	user_id := customer.UserID
	_, err = r.clerkService.UpdateTokenParamsWithCustomerID(ctx, customer.ClerkID.String, user_id.UUID.String(), (customer.CustomerUid), "ADMIN")
	if err != nil {
		fmt.Println("updating public params", err)
	}
	token, err := r.clerkService.SignIn(ctx, user_id.UUID.String())
	if err != nil {
		fmt.Println(" error while generating token ", err)
	}
	fmt.Println("tone", token)

	return &model.VerifyCustomerResponse{
		Success:              true,
		Token:                token,
		OnboardingCompletion: customer.OnboardingCompletion.Bool,
	}, nil
}

// Signin is the resolver for the signin field.
func (r *queryResolver) Signin(ctx context.Context, input model.SigninInput) (*model.SigninReponse, error) {
	panic(fmt.Errorf("not implemented: Signin - signin"))
	// signinToken, err := r.clerkService.SignIn(ctx, in )
}
