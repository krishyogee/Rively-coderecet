// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: customers.sql

package customers

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) AS total_customers
FROM customers
`

func (q *Queries) CountCustomers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomers)
	var total_customers int64
	err := row.Scan(&total_customers)
	return total_customers, err
}

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (customer_uid, domain, email, is_verified)
VALUES (uuid_generate_v4(), $1, $2, $3)
RETURNING id, customer_uid, domain, email, is_verified, created_at
`

type CreateCustomerParams struct {
	Domain     sql.NullString `json:"domain"`
	Email      string         `json:"email"`
	IsVerified sql.NullBool   `json:"is_verified"`
}

type CreateCustomerRow struct {
	ID          int32          `json:"id"`
	CustomerUid uuid.UUID      `json:"customer_uid"`
	Domain      sql.NullString `json:"domain"`
	Email       string         `json:"email"`
	IsVerified  sql.NullBool   `json:"is_verified"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (CreateCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, createCustomer, arg.Domain, arg.Email, arg.IsVerified)
	var i CreateCustomerRow
	err := row.Scan(
		&i.ID,
		&i.CustomerUid,
		&i.Domain,
		&i.Email,
		&i.IsVerified,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteCustomer, id)
	return err
}

const getCustomerById = `-- name: GetCustomerById :one
SELECT id, customer_uid, domain, email, is_verified, created_at, verification_token
FROM customers
WHERE id = $1
`

type GetCustomerByIdRow struct {
	ID                int32          `json:"id"`
	CustomerUid       uuid.UUID      `json:"customer_uid"`
	Domain            sql.NullString `json:"domain"`
	Email             string         `json:"email"`
	IsVerified        sql.NullBool   `json:"is_verified"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	VerificationToken sql.NullString `json:"verification_token"`
}

func (q *Queries) GetCustomerById(ctx context.Context, id int32) (GetCustomerByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerById, id)
	var i GetCustomerByIdRow
	err := row.Scan(
		&i.ID,
		&i.CustomerUid,
		&i.Domain,
		&i.Email,
		&i.IsVerified,
		&i.CreatedAt,
		&i.VerificationToken,
	)
	return i, err
}

const getCustomerByUID = `-- name: GetCustomerByUID :one
SELECT 
    c.id,
    c.customer_uid,
    c.domain,
    c.email,
    c.is_verified,
    c.created_at,
    c.verification_token,
    c.owner_id,
    c.onboarding_completion,
    c.verification_token_sent_at,
    -- Owner details from users table
    u.id as id,
    u.clerk_id as clerk_id,
    u.user_id as user_id,
    u.email as user_email
FROM customers c
LEFT JOIN users u ON c.owner_id = u.id
WHERE c.customer_uid = $1
`

type GetCustomerByUIDRow struct {
	ID                      int32          `json:"id"`
	CustomerUid             uuid.UUID      `json:"customer_uid"`
	Domain                  sql.NullString `json:"domain"`
	Email                   string         `json:"email"`
	IsVerified              sql.NullBool   `json:"is_verified"`
	CreatedAt               sql.NullTime   `json:"created_at"`
	VerificationToken       sql.NullString `json:"verification_token"`
	OwnerID                 sql.NullInt32  `json:"owner_id"`
	OnboardingCompletion    sql.NullBool   `json:"onboarding_completion"`
	VerificationTokenSentAt sql.NullTime   `json:"verification_token_sent_at"`
	ID_2                    sql.NullInt32  `json:"id_2"`
	ClerkID                 sql.NullString `json:"clerk_id"`
	UserID                  uuid.NullUUID  `json:"user_id"`
	UserEmail               sql.NullString `json:"user_email"`
}

func (q *Queries) GetCustomerByUID(ctx context.Context, customerUid uuid.UUID) (GetCustomerByUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByUID, customerUid)
	var i GetCustomerByUIDRow
	err := row.Scan(
		&i.ID,
		&i.CustomerUid,
		&i.Domain,
		&i.Email,
		&i.IsVerified,
		&i.CreatedAt,
		&i.VerificationToken,
		&i.OwnerID,
		&i.OnboardingCompletion,
		&i.VerificationTokenSentAt,
		&i.ID_2,
		&i.ClerkID,
		&i.UserID,
		&i.UserEmail,
	)
	return i, err
}

const getCustomerEmailByUID = `-- name: GetCustomerEmailByUID :one
SELECT email
FROM customers
WHERE customer_uid = $1
`

func (q *Queries) GetCustomerEmailByUID(ctx context.Context, customerUid uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getCustomerEmailByUID, customerUid)
	var email string
	err := row.Scan(&email)
	return email, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, customer_uid, domain, email, is_verified, created_at
FROM customers
ORDER BY created_at DESC
`

type ListCustomersRow struct {
	ID          int32          `json:"id"`
	CustomerUid uuid.UUID      `json:"customer_uid"`
	Domain      sql.NullString `json:"domain"`
	Email       string         `json:"email"`
	IsVerified  sql.NullBool   `json:"is_verified"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListCustomers(ctx context.Context) ([]ListCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomersRow
	for rows.Next() {
		var i ListCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerUid,
			&i.Domain,
			&i.Email,
			&i.IsVerified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customers
SET domain = $2, email = $3, is_verified = $4, verification_token_sent_at = $5
WHERE customer_uid = $1
RETURNING id, customer_uid, domain, email, is_verified, created_at, verification_token_sent_at
`

type UpdateCustomerParams struct {
	CustomerUid             uuid.UUID      `json:"customer_uid"`
	Domain                  sql.NullString `json:"domain"`
	Email                   string         `json:"email"`
	IsVerified              sql.NullBool   `json:"is_verified"`
	VerificationTokenSentAt sql.NullTime   `json:"verification_token_sent_at"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomer,
		arg.CustomerUid,
		arg.Domain,
		arg.Email,
		arg.IsVerified,
		arg.VerificationTokenSentAt,
	)
	return err
}

const updateCustomerDomain = `-- name: UpdateCustomerDomain :one
UPDATE customers
SET domain = $2
WHERE customer_uid = $1
RETURNING id, customer_uid, domain, email, is_verified, created_at
`

type UpdateCustomerDomainParams struct {
	CustomerUid uuid.UUID      `json:"customer_uid"`
	Domain      sql.NullString `json:"domain"`
}

type UpdateCustomerDomainRow struct {
	ID          int32          `json:"id"`
	CustomerUid uuid.UUID      `json:"customer_uid"`
	Domain      sql.NullString `json:"domain"`
	Email       string         `json:"email"`
	IsVerified  sql.NullBool   `json:"is_verified"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) UpdateCustomerDomain(ctx context.Context, arg UpdateCustomerDomainParams) (UpdateCustomerDomainRow, error) {
	row := q.db.QueryRowContext(ctx, updateCustomerDomain, arg.CustomerUid, arg.Domain)
	var i UpdateCustomerDomainRow
	err := row.Scan(
		&i.ID,
		&i.CustomerUid,
		&i.Domain,
		&i.Email,
		&i.IsVerified,
		&i.CreatedAt,
	)
	return i, err
}

const updateCustomerOwnerID = `-- name: UpdateCustomerOwnerID :one
UPDATE customers
SET owner_id = $2
WHERE id = $1
RETURNING id, customer_uid, owner_id, domain, email, is_verified, created_at
`

type UpdateCustomerOwnerIDParams struct {
	ID      int32         `json:"id"`
	OwnerID sql.NullInt32 `json:"owner_id"`
}

type UpdateCustomerOwnerIDRow struct {
	ID          int32          `json:"id"`
	CustomerUid uuid.UUID      `json:"customer_uid"`
	OwnerID     sql.NullInt32  `json:"owner_id"`
	Domain      sql.NullString `json:"domain"`
	Email       string         `json:"email"`
	IsVerified  sql.NullBool   `json:"is_verified"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) UpdateCustomerOwnerID(ctx context.Context, arg UpdateCustomerOwnerIDParams) (UpdateCustomerOwnerIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateCustomerOwnerID, arg.ID, arg.OwnerID)
	var i UpdateCustomerOwnerIDRow
	err := row.Scan(
		&i.ID,
		&i.CustomerUid,
		&i.OwnerID,
		&i.Domain,
		&i.Email,
		&i.IsVerified,
		&i.CreatedAt,
	)
	return i, err
}

const updateCustomerVerification = `-- name: UpdateCustomerVerification :exec
UPDATE customers 
SET is_verified = $2
WHERE customer_uid = $1
`

type UpdateCustomerVerificationParams struct {
	CustomerUid uuid.UUID    `json:"customer_uid"`
	IsVerified  sql.NullBool `json:"is_verified"`
}

func (q *Queries) UpdateCustomerVerification(ctx context.Context, arg UpdateCustomerVerificationParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomerVerification, arg.CustomerUid, arg.IsVerified)
	return err
}

const updateCustomerVerificationToken = `-- name: UpdateCustomerVerificationToken :exec
UPDATE customers
set verification_token = $2
WHERE id = $1
RETURNING id, customer_uid, verification_token
`

type UpdateCustomerVerificationTokenParams struct {
	ID                int32          `json:"id"`
	VerificationToken sql.NullString `json:"verification_token"`
}

func (q *Queries) UpdateCustomerVerificationToken(ctx context.Context, arg UpdateCustomerVerificationTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomerVerificationToken, arg.ID, arg.VerificationToken)
	return err
}

const verifyCustomer = `-- name: VerifyCustomer :exec
UPDATE customers
SET is_verified = TRUE
WHERE id = $1
RETURNING id, customer_uid, domain, email, is_verified, created_at
`

func (q *Queries) VerifyCustomer(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, verifyCustomer, id)
	return err
}
